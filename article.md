# A Pocket Chess Game for ESP32s

by honey the codewitch

MIT License

### Prerequisites

- You'll need a PC with Visual Studio Code installed
- You'll need the PlatformIO VS Code extension installed
- You'll need a Makerfabs ESP Display Parallel 4.3" or a Waveshare ESP32S3 4.3"

## Using this Mess

There's not much to explain here, as the application is pretty simple. You turn it on, and play chess. The white team moves first, as per chess rules.

Turning off the device does not clear the game in session. There is a red reset button in the upper left which will restart the game with a new board.

To move a piece, touch the piece you want and drag it to the desired position. Legal moves are highlighted in blue.

## Coding this Mess

### Technologies Employed:

The heart of the game is my [htcw_chess](https://github.com/codewitch-honey-crisis/htcw_chess) library. This handles implementing the rules of chess. We won't cover its implementation here, but it's fairly well documented at the link.

For the graphics and user interface we're using [htcw_gfx](https://github.com/codewitch-honey-crisis/gfx) and [htcw_uix](https://github.com/codewitch-honey-crisis/uix), respectively.

The application runs under the auspices of Espressif's [ESP-IDF](https://docs.espressif.com/projects/esp-idf/en/release-v5.4/esp32/get-started/index.html) development framework.

It uses Espressif's [LCD Panel API](https://docs.espressif.com/projects/esp-idf/en/release-v5.4/esp32/api-reference/peripherals/lcd/index.html) to handle sending bitmaps generated by htcw_uix to the display.

For input it uses Espressif's [LCD Panel Touch API](https://components.espressif.com/components/espressif/esp_lcd_touch/versions/1.1.2) to read the touch panel.


### Diving into the Code 

`src/main.cpp` contains the primary logic for the application. Let's explore it from top to bottom.

We start with a bunch of boilerplate includes to bring in the various tech outlined above.

In addition to that we have some UI code, and assets. Of these only the assets really need a bit of going over:

```cpp
#define POWER_IMPLEMENTATION
#include "assets/power.hpp"
#define PIECE_IMPLEMENTATION
#include "assets/piece.hpp"
#define OPENSANS_REGULAR_IMPLEMENTATION
#include "assets/OpenSans_Regular.h"  // our font
```
The first two includes are SVG icon packs which are a literal collection of SVG documents embedded in a header. The first one is used for our reset button icon. The second one is used for our chess pieces.

The final include is our TrueType font downloaded from [Font Squirrel](https://fontsquirrel.com) and embedded as a header.

The defines are because the headers are header only libraries. In one translation unit you must declare the associated IMPLEMENTATION define before including the header or it won't link, so we do that here.

Unfortunately, my website is undergoing a major rewrite. I've used new tools to generate these headers that aren't yet available at [honeythecodewitch.com/gfx](https://honeythecodewitch.com/gfx) but until then you can download [gfx_web_temp](https://github.com/codewitch-honey-crisis/gfx_web_temp) and run it locally to get access to the sourcecode generators. You'll need a recent version of Node (22+) and Vite+React installed to run it. You don't need to do this to use this project, but you will need it if you want to generate more asset files.


Okay, next let's import the namespaces for UIX and GFX:

```cpp
using namespace gfx;
using namespace uix;
```
Now declare our font. `const_buffer_stream` wraps a static array as a `stream` so it can be used with GFX functions.
```cpp
// fonts load from streams, so wrap our array in one
static const_buffer_stream font_stream(OpenSans_Regular,sizeof(OpenSans_Regular));
```
and now the display manager:
```cpp
// manages the screens
static uix::display lcd;
```

Next we have the `i2c_initialize()` procedure which initializes the I2C bus on the ESP32. Note that it has a fork for "legacy I2C". The issue here is Espressif has been pushing hard to migrate people to the new I2C subsystem they've developed, but it still doesn't play nicely with all the devices out there. For example, the I/O expander for the Waveshare board will not cooperate with it. I could have just used legacy I2C by itself, but I'm putting together a collection of codebases to bomb Espressif with in the interest of getting some more movement on this I2C problem. This is one of those codebases.

```cpp
static void i2c_initialize()
{
#ifndef LEGACY_I2C
    i2c_master_bus_config_t i2c_mst_config;
    memset(&i2c_mst_config,0,sizeof(i2c_mst_config));
    i2c_mst_config.clk_source = I2C_CLK_SRC_DEFAULT;
    i2c_mst_config.i2c_port = (i2c_port_num_t)LCD_TOUCH_I2C_HOST;
    i2c_mst_config.sda_io_num = (gpio_num_t)LCD_TOUCH_PIN_NUM_SDA;
    i2c_mst_config.scl_io_num = (gpio_num_t)LCD_TOUCH_PIN_NUM_SCL;
    i2c_mst_config.glitch_ignore_cnt = 7;
    i2c_mst_config.flags.enable_internal_pullup = 1;
    i2c_master_bus_handle_t bus;
    ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_mst_config, &bus));
#else
    i2c_config_t i2c_config;
    memset(&i2c_config,0,sizeof(i2c_config));
    i2c_config.master.clk_speed = LCD_TOUCH_SPEED;
    i2c_config.mode = LCD_TOUCH_I2C_HOST;
    i2c_config.sda_io_num = LCD_TOUCH_PIN_NUM_SDA;
    i2c_config.scl_io_num = LCD_TOUCH_PIN_NUM_SCL;
    ESP_ERROR_CHECK(i2c_driver_install((i2c_port_t)LCD_TOUCH_I2C_HOST,I2C_MODE_MASTER,0,0,0));
    ESP_ERROR_CHECK(i2c_param_config((i2c_port_t)LCD_TOUCH_I2C_HOST,&i2c_config));    
#endif
}
```

Now we have the SPIFFS initialization procedure. SPIFFS is used to provide writable non-volatile storage to save the current state of the chess game every time a player moves. That allows it to persist the game when powered down.

```cpp
static void spiffs_initialize(void) {
    esp_vfs_spiffs_conf_t conf;
    memset(&conf, 0, sizeof(conf));
    conf.base_path = "/spiffs";
    conf.partition_label = NULL;
    conf.max_files = 5;
    conf.format_if_mount_failed = 1;
    ESP_ERROR_CHECK(esp_vfs_spiffs_register(&conf));
}
```
Now we need a mechanism to connect UIX to the LCD. Basically UIX produces partial bitmaps that represent a portion of the display, and we need to be able to send those to the display using hardware specific calls. We use the ESP LCD Panel API to do that:
```cpp
// UIX calls this to send bitmaps to the display
static void uix_flush(const gfx::rect16& bounds, const void *bitmap, void *state)
{
    esp_lcd_panel_handle_t panel_handle = (esp_lcd_panel_handle_t)state;
    
    // pass the draw buffer to the driver
    esp_lcd_panel_draw_bitmap(panel_handle, bounds.x1, bounds.y1, bounds.x2 + 1, bounds.y2 + 1, bitmap);
}
```
It should be noted that the ESP LCD Panel API is a bit quirky, in that X2 and Y2 need to be 1 more than the actual destination coordinate, as accounted for above.

Sending bitmaps to the display is a non-blocking operation. It doesn't wait until the transfer is complete to return execution to the caller. Instead it initiates a background DMA transfer and then immediately returns. In order to take advantage we must notify UIX when the transfer has been completed:
```cpp
// LCD Panel API calls this
bool lcd_flush_complete(esp_lcd_panel_handle_t panel, const esp_lcd_rgb_panel_event_data_t *edata, void *user_ctx) {
    // let the display know the flush has finished
    lcd.flush_complete();
    return true;
}
```
Furthermore, in order to prevent tearing we only want to begin updating the display during the vertical sync period:
```cpp
static volatile bool lcd_is_vsync = 0;
// LCD Panel API calls this
bool lcd_vsync(esp_lcd_panel_handle_t panel, const esp_lcd_rgb_panel_event_data_t *edata, void *user_ctx) {
    lcd_is_vsync=1;
    return true;
}
```
Here we set a flag indicating vsync is active. We clear it later when we draw.

Next we have the `lcd_initialize()` function which initializes the ESP LCD Panel API for the display. This is set up to use the RGB interface mode since the supported devkits use that facility. I won't be posting it here since it is pretty long, and fairly uninteresting.

In addition to connecting UIX to the LCD Panel API in order to facilitate sending bitmaps to the display, we must also connect UIX to the touch panel in order to get input events:
```cpp
// UIX calls this
static void uix_touch(point16* out_locations,
                                           size_t* in_out_locations_size,
                                           void* state)
{
    esp_lcd_touch_handle_t handle = (esp_lcd_touch_handle_t)state;
    if(ESP_OK==esp_lcd_touch_read_data(handle)) {
        uint16_t x[5],y[5],s[5];
        uint8_t count;
        if(esp_lcd_touch_get_coordinates(handle,x,y,s,&count,5)) {
            if(count>*in_out_locations_size) {
                count = *in_out_locations_size;
            }
            *in_out_locations_size = count;
            for(size_t i = 0;i<(size_t)count;++i) {
                // the panel may have a different res than the screen
                x[i]=x[i]*LCD_HRES/LCD_TOUCH_HRES;
                y[i]=y[i]*LCD_VRES/LCD_TOUCH_VRES;
                out_locations[i]=point16(x[i],y[i]);
            }
            return;
        }
    }
    *in_out_locations_size = 0;
}
```
Similar to `lcd_initialize()` we have `touch_initialize()` which handles the ESP LCD Touch Panel API initialization for an I2C touch panel. I'll be omitting this one as well for similar reasons.

Now let's move on to chess related code.

First some variables to hold our chess piece bitmap info:
```cpp
static size16 chess_piece_bmp_dim;
static uint8_t* chess_piece_bmp_data[6];
```
Now some arrays to map our chess piece SVGs and their metrics:
```cpp
static const_buffer_stream* chess_piece_svg[] = {
    &piece_chess_pawn,
    &piece_chess_bishop,
    &piece_chess_rook,
    &piece_chess_knight,
    &piece_chess_queen,
    &piece_chess_king
};
static sizef chess_piece_size[] = {
    piece_chess_pawn_dimensions,
    piece_chess_bishop_dimensions,
    piece_chess_rook_dimensions,
    piece_chess_knight_dimensions,
    piece_chess_queen_dimensions,
    piece_chess_king_dimensions
};
```
The next little helper function corrects the aspect ratio of an SVG within a bounding box so that our chess pieces don't get squished:
```cpp
static gfx::rectf correct_aspect(const gfx::rect16& r, float aspect) {
    rect16 result = r;
    if (aspect>=1.f) {
        result.y2 /= aspect;
    } else {
        result.x2 *= aspect;
    }
    return (gfx::rectf)result;
}
```
Because this code is generalized for different displays, we use the scalability feature of SVGs in order to render the pieces. However, SVG rendering is expensive, both in terms of RAM and CPU cycles. Therefore, we prerender the SVG chess pieces to small alpha transparency bitmaps we can use later with the GFX `draw::icon()` method:
```cpp
// Take the SVG chess pieces, scale them to the target size and rasterize them
static bool create_piece_data(uint16_t piece_size) {
    memset(chess_piece_bmp_data,0,sizeof(chess_piece_bmp_data));
    chess_piece_bmp_dim  = {piece_size,piece_size};
    for(size_t i = 0;i<6;++i) {
        // create a new bitmap in 4-bit grayscale
        auto bmp = create_bitmap<gsc_pixel<4>>({piece_size,piece_size});
        if(bmp.begin()==nullptr) {
            // out of memory
            goto error;
        }
        // fill with white
        bmp.fill(bmp.bounds(),gsc_pixel<4>(15));
        // assign the bitmap array entry to the bitmap's buffer
        chess_piece_bmp_data[i]=bmp.begin();
        canvas cvs(bmp.dimensions());
        if(gfx_result::success!=cvs.initialize()) {
            // out of memory
            goto error;
        }
        // link the canvas and the bitmap so the canvas can draw on it
        if(gfx_result::success!=draw::canvas(bmp,cvs)) {
            // can't imagine why this would fail
            puts("Failed to bind canvas to bitmap");
            goto error;
        }
        sizef cps = chess_piece_size[i];
        gfx::rectf corrected = correct_aspect(bmp.bounds(), cps.aspect_ratio());
        corrected.center_inplace((gfx::rectf)bmp.bounds());
        matrix fit = matrix::create_fit_to(cps,corrected);
        const_buffer_stream& stm = *chess_piece_svg[i];
        stm.seek(0); // make sure we're at the beginning. render doesn't seek
        if(gfx_result::success!=cvs.render_svg(stm,fit)) {
            puts("Error rasterizing SVG");
            goto error;
        }
        cvs.deinitialize();
        // invert, because it's black on white, but we need an alpha transparency map
        const size_t size = bitmap<gsc_pixel<4>>::sizeof_buffer(bmp.dimensions());
        for(size_t j = 0;j<size;++j) {
            uint8_t d = chess_piece_bmp_data[i][j];
            chess_piece_bmp_data[i][j]=255-d;
        }
    }
    return true;
error:
    for(size_t i = 0; i < 6; ++i) {
        if(chess_piece_bmp_data[i]!=NULL) {
            free(chess_piece_bmp_data[i]);
            chess_piece_bmp_data[i]=NULL;
        }
    }
    puts("Error creating pieces");
    return false;
}
```
GFX and UIX rely on Generic Programming for some of their facilities, so it's typical to alias types quite a bit.
Here we declare our screen's bitmap pixel format. This is the format of the bitmap sent to `uix_flush()`. We also declare X11 color enumerations in various formats because different formats are used by the screen, the GFX vector canvas, and UIX. Finally we alias the screen type by declaring one in our pixel format.
```cpp
// declare our core GFX and UIX types
using pixel_t = rgb_pixel<LCD_BIT_DEPTH>; // screen bitmap format
using color_t = color<pixel_t>; // color enum (screen native)
using vcolor_t = color<vector_pixel>; // color enum (vector)
using uix_color_t = color<rgba_pixel<32>>; // color enum (UIX)
using screen_t = screen<pixel_t>; // the screen
```

I don't care for the following, but it is expedient and it works. Basically, when a pawn reaches the end of the board, it will be promoted to a selected type - usually a queen, although in rare cases, a knight can be more beneficial. The problem this introduces for the UI is that once promoted, that piece and its square need to be redrawn. There's no easy way to know this from inside the controls themselves, so we handle it outside the main board and promotion controls, in the main application loop.
```cpp
// Workaround: When a piece gets promoted it needs to be redrawn, but
// we won't know that within the chess board itself, so we set
// it in the board and check it in the app loop and use it to invalidate
// the right square
static chess_index_t just_promoted = -1;
```

UIX uses a "control" paradigm wherein you have simple rectangularly bounded controls that are responsible for drawing themselves and responding to input. It's typical to create controls for UI elements when there are no built-ins that are suitable. In this case we've created one that renders the chess piece promotion menu:

```cpp
// The control to display the chess promotion UI
template <typename ControlSurfaceType>
class chess_promotion : public control<ControlSurfaceType> {
    using base_type = control<ControlSurfaceType>;
public:
    using control_surface_type = ControlSurfaceType;
    using pixel_type = typename ControlSurfaceType::pixel_type;
    using palette_type = typename ControlSurfaceType::palette_type;
```
You can see it's a template class that derives from a `control<>` tempalte. `ControlSurfaceType` is the draw surface that the screen will pass in which is used for rendering the control, and is based on the screen's native pixel (and palette) format.

Then there's some boilerplate copy and move overloads, as well as a couple of constructors:
```cpp
/// @brief Constructs a chess_promotion from a given parent with an optional palette
/// @param parent The parent the control is bound to - usually the screen
/// @param palette The palette associated with the control. This is usually the screen's palette.
chess_promotion(invalidation_tracker& parent, const palette_type* palette = nullptr) : base_type(parent, palette) {
    init();
}
/// @brief Constructs a chess_promotion from a given parent with an optional palette
chess_promotion() : base_type() {
    init();
}
```
The first constructor *strictly* isn't required, but legacy UIX code did require it in the prerelease version, so I include it for convention, completeness and backward compatibility reasons since all the base controls also implement a constructor taking those arguments. In each case we forward to the `init()` function which just sets some initial values.

I'm not going to cover the entire control here, as some of it is just helper and accessor methods and other boilerplate, but the interesting stuff is `on_paint()`, `on_touch()` and `on_release()`:

```cpp
void on_paint(control_surface_type& destination, const srect16& clip) override {
    const int16_t extent = this->dimensions().width;
    const int16_t sq_width = (extent/4);
    const int idx = point_to_square(m_last_touch);
    int type = 1;
    for(int x = 0; x < extent; x+=sq_width) {
        const ssize16 square_size(sq_width,sq_width);
        const srect16 square(spoint16(x,0),square_size);
        auto bg = uix_color_t::dark_green,
            bd = uix_color_t::dark_olive_green;
        if(idx==(x/sq_width)) {
            bg=uix_color_t::green;
            bd=uix_color_t::dark_green;
        }
        draw::filled_rectangle(destination,square,uix_color_t::dark_green);
        draw::rectangle(destination,square.inflate(-2,-2),uix_color_t::dark_olive_green);
        const auto ico = const_bitmap<alpha_pixel<4>>(chess_piece_bmp_dim,chess_piece_bmp_data[(size_t)type]);
        const srect16 icon = ((srect16)ico.bounds()).center(square_size.bounds()).offset(x, 0);
        draw::icon(destination,icon.top_left(),ico,uix_color_t::khaki);
        ++type;
    }
}
bool on_touch(size_t locations_size, const spoint16* locations) override {
    if(locations_size) {
        m_last_touch = locations[0];
    }
    return true;
}
void on_release() override {
    if(m_game!=nullptr && m_index>-1 && m_index<64) {
        chess_type_t type = (chess_type_t)(1+point_to_square(m_last_touch));
        if(CHESS_SUCCESS==chess_promote_pawn(m_game,m_index,type)) {
            just_promoted = m_index;
        }
    }
    this->visible(false);
}
```
`on_paint()` is called by UIX to render the control to the control surface which is of type `control_surface_type`. It passes an instance of that, and the current clipping rectangle, the latter of which we won't need here, although generally it can be used so that you only need to draw a portion of the control.

What we're doing here is taking the current touched square so we can highlight it, and then going through and drawing the squares and pieces that can be promoted. Note we use `draw::icon()` with the alpha transparency maps created earlier.

In `on_touch()` we just just set the `m_last_touch` field to the location of the first touch point we receive.

That's because in a UI typically we want the "meat" of an input to be handled on release. You may have several touch events for each release event, so it makes more sense to do an action once the button or whatever it is is depressed rather than pressed. To that end we handle the bulk of the input work in `on_release()` where we tell the chess engine that we promoted a pawn, and assuming it was successful, which it should be, we set that `just_promoted` workaround mentioned earlier so the appropriate board square can be redrawn afterward.

Next we need some types for our controls, which we need here because they will be referenced by the chess board:

```cpp
// the screen has a control surface type used by each control
// which presents a drawing surface
using surface_t = screen_t::control_surface_type;
using chess_promotion_t = chess_promotion<surface_t>;
using label_t = vlabel<surface_t>;
using icon_t = vicon<surface_t>;
```

We also need some instances of those controls:

```cpp
static chess_promotion_t promotion_top;
static chess_promotion_t promotion_bottom;
static char score_white_text[32], score_black_text[32];
static label_t score_white, score_black;
```
Note how we have string buffers to hold the text for the scores. The reason for this is that UIX is loath to allocate memory. It expects you to, so when you set the text of a control, it is your responsibility to ensure that the buffer that holds that text sticks around. UIX does not do this for you.

Next we have the actual board control. This handles the primary game logic, rendering and input, with the help of `htcw_chess` to implement the rules.

Rather than cover the entire control, we'll go over the most important bits, starting with some private state:

```cpp
chess_game_t m_game;
chess_index_t m_moves[64];
size_t m_moves_size;
chess_index_t m_touched;
spoint16 m_last_touch;
```
The first field holds the game state used by the `htcw_chess` engine. The second field is a buffer that holds possible moves for a given position. It can hold up to 64 moves, so that is enough to even cover the whole board. The field that follows is a value containing the count of actual moves in the aforementioned move buffer. Next we have a value indicating which board index was last touched, and then a signed 16-bit 2D point that contains the location of the last touch.

There are a couple of helper methods to get square boundaries, `point_to_square()` which takes a touch point and returns the square that occupies it, and `square_coords()` which takes a bound index and gets the bounding square for it:

```cpp
int point_to_square(spoint16 point) {
    const int16_t extent = this->dimensions().aspect_ratio() >= 1 ? this->dimensions().height : this->dimensions().width;
    const int x = point.x / (extent / 8);
    const int y = point.y / (extent / 8);
    return y * 8 + x;
}
void square_coords(int index, srect16* out_rect) {
    const int16_t extent = this->dimensions().aspect_ratio() >= 1 ? this->dimensions().height : this->dimensions().width;
    const ssize16 square_size(extent / 8, extent / 8);
    const int x = index % 8;
    const int y = index / 8;
    const spoint16 origin(x * (extent / 8), y * (extent / 8));
    *out_rect = srect16(origin, square_size);
}
```
As with the previous control, most of the interesting logic is in `on_paint()`, `on_touch()` and `on_release()`. Let's start with `on_paint()`:

The first thing we do is take the extent of the board. In case it's a rectangle, it's based on the shortest side. The square size is 1/8th of the board size.

The toggle flag helps create the checkerboard pattern, and idx counts our current board index.

As we go through the board, we see if we're in the clipping rectangle (if not we skip drawing that portion), and if so we check to see if there's a chess piece.

If we have one we corner case for a king in check, by giving the square a red border, otherwise it gets the default border.

Next, if the current square is touched, is contained among the legal moves (computed elsewhere) for the current index we indicate that with `is_move = true` and change the background to light blue.

If it's not a move we just draw the square. If it is a move, we draw the square, and then draw the highlighted portion in blue.

Finally, if the index has a chess piece at the location, we wrap it with a `const_bitmap<alpha_pixel<4>>` transparency map and then draw the icon in the appropriate team color.

```cpp
void on_paint(control_surface_type& destination, const srect16& clip) override {
    const int16_t extent = destination.dimensions().aspect_ratio() >= 1 ? destination.dimensions().height : destination.dimensions().width;
    const ssize16 square_size(extent / 8, extent / 8);
    bool toggle = false;
    int idx = 0;
    for (int y = 0; y < extent; y += square_size.height) {
        int i = toggle;
        for (int x = 0; x < extent; x += square_size.width) {
            const srect16 square(spoint16(x, y), square_size);
            if (square.intersects(clip)) {
                const chess_id_t id = chess_index_to_id(&m_game,idx);
                const auto bg = (i & 1) ? uix_color_t::brown : uix_color_t::dark_khaki;
                const auto bd = (i & 1) ? uix_color_t::gold : uix_color_t::black;
                auto px_bg = bg;
                auto px_bd = bd;
                if (id > -1 && CHESS_TYPE(id) == CHESS_KING && chess_status(&m_game,CHESS_TEAM(id)) == CHESS_CHECK) {
                    px_bd = uix_color_t::red;
                }
                bool is_move = false;
                if (m_touched == idx || chess_contains_move(m_moves, m_moves_size, idx)) {
                    px_bg = uix_color_t::light_blue;
                    is_move = true;
                }
                
                if(!is_move) {
                    draw::filled_rectangle(destination, square, px_bg);
                    draw::rectangle(destination, square.inflate(-2, -2), px_bd); 
                } else {
                    draw::filled_rectangle(destination, square, bg);
                    draw::rectangle(destination, square.inflate(-2, -2), px_bd);
                    const int16_t deflate = (idx==m_touched)?0: -(square_size.width/4);
                    draw::filled_rectangle(destination, square.inflate(deflate,deflate), px_bg);
                    
                }
                if (CHESS_NONE != id) {
                    auto ico = const_bitmap<alpha_pixel<4>>(chess_piece_bmp_dim,chess_piece_bmp_data[CHESS_TYPE(id)]);
                    const srect16 bounds = ((srect16)ico.bounds()).center(square_size.bounds()).offset(x, y);
                    auto px_piece = CHESS_TEAM(id) ? uix_color_t::black : uix_color_t::white;
                    draw::icon(destination, bounds.location(), ico, px_piece);
                }
            }
            ++i;
            ++idx;
        }
        toggle = !toggle;
    }
}
```

When the board is touched, assuming a promotion is not in progress, and a touch hasn't already occurred, then if a piece is touched from the team whose turn it currenty is, the available moves are computed for the piece at that location, stored in `m_moves`. Furthermore each square that applies is invalidated so that it will be redrawn. If a touch already occurred we just update the position of it.

```cpp
bool on_touch(size_t locations_size, const spoint16* locations) override {
    if(promotion_bottom.visible() || promotion_top.visible()) {
        return false;
    }
    if (m_touched > -1) {
        if (locations_size) m_last_touch = locations[0];
        return true;
    }
    if (locations_size) {
        const int16_t extent = this->dimensions().aspect_ratio() >= 1 ? this->dimensions().height : this->dimensions().width;
        const srect16 square(spoint16::zero(), ssize16(extent / 8, extent / 8));
        int sq = point_to_square(*locations);
        if (sq > -1) {
            const chess_id_t id = chess_index_to_id(&m_game,sq);
            if (id > -1) {
                const chess_team_t team = CHESS_TEAM(id);
                if (chess_turn(&m_game) == team) {
                    m_touched = sq;
                    m_moves_size = chess_compute_moves(&m_game,sq,m_moves);
                    srect16 sq_bnds;
                    square_coords(sq, &sq_bnds);
                    this->invalidate(sq_bnds);
                }
            }
            if (m_moves_size > 0) {
                for (size_t i = 0; i < m_moves_size; ++i) {
                    srect16 sq_bnds;
                    square_coords(m_moves[i], &sq_bnds);
                    this->invalidate(sq_bnds);
                }
                return true;
            }
        }
    }
    return false;
}
```
Once again, release is where the meat is handled.

Here, using the last touched index we get the id and from there the team. We compute the actual extent of the board (in the case of a rectangle, taking the shortest edge) and compute the x and y offsets for the square that was touched. We use that to invalidate the square, before going through the avaialable moves (if we had a valid move) and invalidating those squares as well. This will cause a redraw of the affected areas. If we had a valid move The release index will be the location we last touched. If it's a valid index we issue a `chess_move()` call to the chess engine to update the board. We already know it will succeed because it's among the valid moves we computed earlier, so we don't have to recheck for success here. Instead we just check to see if there was a "victim" (a target piece taken from the opposing team due to the move). This is usually the release index in the case where there was an opposition piece in the final square, but with en passant captures that's not the case, so the chess engine returns the victim square if there was one, or `CHESS_NONE` (-1) otherwise.

Once we've updated the board, we write the board state to the chess file on SPIFFS. We do this on every move so the game can be turned off at any time (except during promotion - a current limitation of the code). 

If we took a piece (victim is not `CHESS_NONE`) update the appropriate score buffer and label text, causing it to invalidate and be redrawn. We have to corner case for en passant to ensure the victim square gets invalidated.

Next, we check to see if a promotion is in order. This will be true if the current piece is a pawn and is on the opposite end of the board from which it started out. If so we pop a promotion control.

We set the moves size to zero to reset the moves buffer, and finally, we reset the `m_touched` value to none (-1).

```cpp
void on_release() override {
    if (m_touched > -1) {
        const chess_id_t id = chess_index_to_id(&m_game,m_touched);
        const chess_team_t team = CHESS_TEAM(id);
        const int16_t extent = this->dimensions().aspect_ratio() >= 1 ? this->dimensions().height : this->dimensions().width;
        const srect16 square(spoint16::zero(), ssize16(extent / 8, extent / 8));
        const int x = m_touched % 8 * (extent / 8), y = m_touched / 8 * (extent / 8);
        this->invalidate(square.offset(x, y));
        if (m_moves_size > 0) {
            for (size_t i = 0; i < m_moves_size; ++i) {
                srect16 sq_bnds;
                square_coords(m_moves[i], &sq_bnds);
                this->invalidate(sq_bnds);
            }
            const int release_idx = point_to_square(m_last_touch);
            if (release_idx != -1) {
                chess_index_t victim = chess_move(&m_game,m_touched,release_idx);
                FILE* f = fopen("/spiffs/chess.bin","wb");
                if(f!=NULL) {
                    fwrite(&m_game,1,sizeof(m_game),f);
                    fclose(f);
                }    
                srect16 sq_bnds;
                square_coords(release_idx, &sq_bnds);
                this->invalidate(sq_bnds);
                if(victim!=CHESS_NONE) { 
                    // update the score
                    chess_score_t score = chess_score(&m_game, team);
                    if(team==0) {
                        sprintf(score_white_text,"%d",(int)score);
                        score_white.text(score_white_text);
                    } else {
                        sprintf(score_black_text,"%d",(int)score);
                        score_black.text(score_black_text);
                    }
                    if(victim!=release_idx) { // en passant
                        square_coords(victim,&sq_bnds);
                        this->invalidate(sq_bnds);
                    }
                }
                if(CHESS_TYPE(id)==CHESS_PAWN) { // check for a promotion
                    if(team==CHESS_WHITE && release_idx>=64-8) {
                        // promote 
                        promotion_bottom.game(m_game);
                        promotion_bottom.index(release_idx);
                        promotion_bottom.visible(true);
                    } else if(team==CHESS_BLACK && release_idx<8) {
                        // promote 
                        promotion_top.game(m_game);
                        promotion_top.index(release_idx);
                        promotion_top.visible(true);
                    }
                }
            }
            m_moves_size = 0;
        }
    }
    m_touched = -1;
}
};
```

That wraps up the primary game logic. The rest is just setup and reset handling, but first we need to declare a few things:

```cpp
using chess_board_t = chess_board<surface_t>;
static screen_t main_screen;
static chess_board_t board;
static icon_t reset_button;
```
This is just some mess for our screen and controls.


We'll visit the reset handling now:

Once again, we handle on release, not on press. If we have a release we initialize a new `chess_game_t` structure and save it to SPIFFS. After that we simply restart the ESP32. While this isn't strictly necessary - it would be possible to do an internal "light" reset of all of the state, extending the application would be more complicated, as adding additional state would also require it to be reset properly here, adding a potential site for bugs.
```cpp
static void reset_button_on_pressed_changed(bool pressed, void* state) {
    if(!pressed) {
        chess_game_t g;
        chess_init(&g);
        FILE* f = fopen("/spiffs/chess.bin", "wb");
        if(f!=NULL) {
            fwrite(&g,1,sizeof(g),f);
            fclose(f);
        }
        esp_restart();
    }
}
```
Finally, we have the main application code.

The first thing we do is initialize our devices:

```cpp
printf("ESP-IDF version: %d.%d.%d\n",ESP_IDF_VERSION_MAJOR,ESP_IDF_VERSION_MINOR,ESP_IDF_VERSION_PATCH);
i2c_initialize();
spiffs_initialize();
lcd_initialize();
touch_initialize();
```
Next we compute and set some dimensions for the screen and piece size, followed by actually creating the piece data and a couple more computations:

```cpp
main_screen.dimensions({LCD_WIDTH,LCD_HEIGHT});
const float screen_aspect = main_screen.dimensions().aspect_ratio();
int16_t piece_size = 0;
if(screen_aspect>1.f) {
    piece_size= main_screen.dimensions().height/8;
} else if(screen_aspect<1.f) {
    piece_size = main_screen.dimensions().width/8;
} else {
    piece_size = main_screen.dimensions().width/10;
}
srect16 board_bounds(spoint16::zero(),ssize16(piece_size*8,piece_size*8));
board_bounds.center_inplace(main_screen.bounds());
main_screen.background_color(color_t::black);
if(!create_piece_data(piece_size)) {
    puts("could not crete pieces");
    return;
}
const size16 sq_size(piece_size,piece_size);
srect16 contained;
if(screen_aspect<=1.f) {
    contained = srect16(0,0,main_screen.dimensions().width-1,board.bounds().y1-1);
} else {
    contained = srect16(0,0,main_screen.dimensions().width-1,piece_size-1);
}
```
After that we set the board bounds, initialize the game, loading from SPIFFS if available, and assign the initialized game instance to the controls, followed by registering the board control with the screen.
```cpp
board.bounds(board_bounds);
FILE* f = fopen("/spiffs/chess.bin","rb");
chess_game_t g;
if(f!=NULL) {
    if(sizeof(g)!=fread(&g,1,sizeof(g),f)) {
        chess_init(&g);
    }
    fclose(f);
} else {
    chess_init(&g);
}
board.game(g);
promotion_top.game(g);
promotion_bottom.game(g);
main_screen.register_control(board);
```
Now we're going to go through each control in turn, set it up and register it with the screen, starting with the reset button.

We basically just feed the icon an SVG, the dimensions of it (since they are already computed), and a callback for when it's pressed.

```cpp
reset_button.bounds(srect16(0,0,piece_size-1,piece_size-1));
reset_button.background_color(uix_color_t::orange_red);
reset_button.svg(power_power_off);
reset_button.svg_dimensions(power_power_off_dimensions);
reset_button.on_pressed_changed_callback(reset_button_on_pressed_changed);
main_screen.register_control(reset_button);
```

Now we set up and register the promotion controls. These are invisible to start with, but we place them and configure them now:

```cpp
const srect16 promo_rect(0,0,piece_size*4-1,piece_size-1);
promotion_top.bounds(promo_rect.center(contained));
promotion_top.visible(false);
main_screen.register_control(promotion_top);
contained.offset_inplace(0,main_screen.dimensions().height-contained.height());
promotion_bottom.bounds(promo_rect.center(contained));
promotion_bottom.visible(false);
main_screen.register_control(promotion_bottom);
```

We keep reusing our contained rect from earlier and adjusting it for the coordinates of each control.

Here we prepare it based on the screen metrics for placement of the white team score before setting up the control, including the font, background, etc.

```cpp
if(screen_aspect<=1.f) {
    contained = srect16(0,0,board.bounds().x1-1,board.bounds().x1-1);
    contained.center_vertical_inplace(main_screen.bounds());
} else {
    contained = srect16(0,0,board.bounds().x1-1,board.bounds().x1-1);
    contained.center_vertical_inplace(main_screen.bounds());
}
contained.inflate_inplace(-2,-2);
score_white.bounds(contained);
score_white.font(font_stream);
score_white.text_justify(uix_justify::center);
score_white.background_color(uix_color_t::green);
score_white.color(uix_color_t::white);
sprintf(score_white_text,"%d",(int)chess_score(&g,CHESS_WHITE));
score_white.text(score_white_text);
main_screen.register_control(score_white)
```
And we do similar for the black score:

```cpp
if(screen_aspect<=1.f) {
    contained = srect16(board.bounds().x2+1,0,main_screen.bounds().x2,contained.width()-1);
    contained.center_vertical_inplace(main_screen.bounds());
} else {
    contained = srect16(0,0,board.bounds().x1-1,board.bounds().x1-1);
    contained.offset_inplace(main_screen.dimensions().width-contained.width(),0);
    contained.center_vertical_inplace(main_screen.bounds());
}
score_black.font(font_stream);
score_black.text_justify(uix_justify::center);
score_black.bounds(contained);
score_black.background_color(uix_color_t::dark_olive_green);
score_black.color(uix_color_t::black);
sprintf(score_black_text,"%d",(int)chess_score(&g,CHESS_BLACK));
score_black.text(score_black_text);
main_screen.register_control(score_black);
```
Now we just set the active screen to the `main_screen` instance, and that competes the UI setup:

```cpp
lcd.active_screen(main_screen);
```

On to the application loop. We keep a couple of timestamps. One is to feed the ESP32's watchdog timer so it doesn't reboot on us. The other one is for blinking the score of whichever team is up once a second:

```cpp
uint32_t ms = pdTICKS_TO_MS(xTaskGetTickCount());
uint32_t blink_turn_ms = 0;
```

Our main application loop handles feeding the watchdog timer, blinking the active score control, and invalidating the square for a piece that was just promoted. Aside from that, it updates the display on vertical sync:

```cpp
while(1) {
    if(pdTICKS_TO_MS(xTaskGetTickCount()) >= ms+200) {
        ms = pdTICKS_TO_MS(xTaskGetTickCount());
        vTaskDelay(5);
    }
    if(pdTICKS_TO_MS(xTaskGetTickCount()) >= blink_turn_ms+500) {
        // blink the active turn score label
        blink_turn_ms = pdTICKS_TO_MS(xTaskGetTickCount());
        if(CHESS_WHITE==board.turn()) {
            score_white.visible(!score_white.visible());
            score_black.visible(true);
        } else {
            score_black.visible(!score_black.visible());
            score_white.visible(true);
        }
    }
    if(just_promoted!=-1) {
        const int16_t extent = board.dimensions().aspect_ratio()>=1.f?board.dimensions().width:board.dimensions().height;
        const ssize16 square_size(extent / 8, extent / 8);
        const int x = just_promoted % 8;
        const int y = just_promoted / 8;
        const spoint16 origin(x * (extent / 8), y * (extent / 8));
        just_promoted = -1;
        main_screen.invalidate(srect16(origin.offset(board.bounds().top_left()),square_size));
    }
    if(lcd_is_vsync==1) {
        lcd_is_vsync=0;
        lcd.update();
    }
}
```

That's all folks! Enjoy.

